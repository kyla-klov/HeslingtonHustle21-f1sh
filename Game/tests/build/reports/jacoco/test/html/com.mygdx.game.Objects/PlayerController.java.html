<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>PlayerController.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">tests</a> &gt; <a href="index.source.html" class="el_package">com.mygdx.game.Objects</a> &gt; <span class="el_source">PlayerController.java</span></div><h1>PlayerController.java</h1><pre class="source lang-java linenums">package com.mygdx.game.Objects;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.Input;
import com.badlogic.gdx.InputProcessor;
import com.badlogic.gdx.graphics.Camera;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.graphics.glutils.ShapeRenderer;
import com.badlogic.gdx.math.Rectangle;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.IntSet;
import com.mygdx.game.HesHustle;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.mygdx.game.Utils.EventManager;
import com.mygdx.game.Utils.CollisionDetector;

import java.util.Objects;

/**Controller Class which the user interacts with the game through, has input processor which must be set active on each GameScreen
 *
 */
public class PlayerController extends GameObject implements InputProcessor {
    /**Width of character sprite
     */
    public static final float width = 32;
    /**Height of character sprite
     */
    public static final float height = 64;

    /**Enum of states the player character can be in
     */
<span class="nc" id="L33">    public enum state {</span>
<span class="nc" id="L34">        IDLE_LEFT,</span>
<span class="nc" id="L35">        IDLE_UP,</span>
<span class="nc" id="L36">        IDLE_RIGHT,</span>
<span class="nc" id="L37">        IDLE_DOWN,</span>
<span class="nc" id="L38">        WALK_LEFT,</span>
<span class="nc" id="L39">        WALK_UP,</span>
<span class="nc" id="L40">        WALK_RIGHT,</span>
<span class="nc" id="L41">        WALK_DOWN,</span>
    }

    /**
     * Animation for each state
     */
    Animation IDLE_LEFT,
            IDLE_UP,
            IDLE_RIGHT,
            IDLE_DOWN,
            WALK_LEFT,
            WALK_UP,
            WALK_RIGHT,
            WALK_DOWN;
    /**Current state of player
     */
    public state Pstate;
    /**Current player animation
     */
    public Animation panim;
    /**Stores current texture region to be rendered
     *
     */
    TextureRegion txr;
    /**IntSet storing the key values of every key being pressed
     * (Still has trouble with more than 3 inputs)
     */
<span class="nc" id="L68">    private final IntSet downKeys = new IntSet(20);</span>
    /**Stores the Key values of the direction keys you want to use
     */
    private final static int up=Input.Keys.W,down=Input.Keys.S,left=Input.Keys.A,right=Input.Keys.D;
    /**Event Manager used to interact with events*/
    public EventManager EM;
    /**Ref to nearest building (Activity) for interaction*/
    public Building nearBD;
    /**Detects player collision
     *
     */
    CollisionDetector collisionDetector;

    /**
     * Constructor of PlayerController
     * @param xPos Initial x position
     * @param yPos Initial y position
     * @param EM EventManager
     * @param collisionLayer Collision Layer of the Tiled Map
     */
    public PlayerController(float xPos, float yPos, EventManager EM, TiledMapTileLayer collisionLayer) {
<span class="nc" id="L89">        super(xPos,yPos,width,height);</span>
<span class="nc" id="L90">        Pstate = state.IDLE_DOWN;</span>
<span class="nc" id="L91">        loadAnims();</span>
<span class="nc" id="L92">        panim = IDLE_DOWN;</span>
<span class="nc" id="L93">        this.EM = EM;</span>
<span class="nc" id="L94">        nearBD = null;</span>


        // Initialize the detector
<span class="nc" id="L98">        collisionDetector = new CollisionDetector(this, collisionLayer);</span>

<span class="nc" id="L100">    }</span>

    /**
     * Function to generate all the Animations from the sprite sheets
     */
    private void loadAnims() {
<span class="nc" id="L106">        IDLE_LEFT = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_idle_anim_16x16.png&quot;)),12,17,24,12);</span>
<span class="nc" id="L107">        IDLE_UP = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_idle_anim_16x16.png&quot;)),6,11,24,12);</span>
<span class="nc" id="L108">        IDLE_RIGHT = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_idle_anim_16x16.png&quot;)),0,5,24,12);</span>
<span class="nc" id="L109">        IDLE_DOWN = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_idle_anim_16x16.png&quot;)),18,23,24,12);</span>
<span class="nc" id="L110">        WALK_LEFT = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_run_16x16.png&quot;)),12,17,24,12);</span>
<span class="nc" id="L111">        WALK_UP = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_run_16x16.png&quot;)),6,11,24,12);</span>
<span class="nc" id="L112">        WALK_RIGHT = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_run_16x16.png&quot;)),0,5,24,12);</span>
<span class="nc" id="L113">        WALK_DOWN = new Animation(new Texture(Gdx.files.internal(&quot;Amelia_run_16x16.png&quot;)),18,23,24,12);</span>
<span class="nc" id="L114">    }</span>

    /**
     * Update function extended from GameObject
     * @param deltaTime deltaTime
     */
    public void update (float deltaTime) {
        //get texture region to draw
<span class="nc" id="L122">        txr = getAnim(Pstate).GetFrame(deltaTime);</span>
        //update position using normalised direction vector using vector addition (delta time in scalar)
<span class="nc bnc" id="L124" title="All 2 branches missed.">        if (!EM.isFrozen()){</span>
<span class="nc" id="L125">            pos = pos.mulAdd(colCorrect(getDir()).nor(),deltaTime*300);</span>
        }
<span class="nc" id="L127">    }</span>
<span class="nc" id="L128">    public Vector2 getPos() { return pos; }</span>

<span class="nc" id="L130">    public Rectangle getBounds() { return new Rectangle(bounds.x, bounds.y, bounds.width, bounds.height); }</span>


    public Vector2 getDir() {
        //find overall direction of inputs
<span class="nc" id="L135">        Vector2 dir = new Vector2(0,0);</span>
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (downKeys.contains(up)){</span>
<span class="nc" id="L137">            dir.y = 1;</span>
<span class="nc" id="L138">            Pstate = state.WALK_UP;</span>
        }
<span class="nc bnc" id="L140" title="All 2 branches missed.">        if (downKeys.contains(down)){</span>
<span class="nc" id="L141">            dir.y = -1;</span>
<span class="nc" id="L142">            Pstate = state.WALK_DOWN;</span>
        }
<span class="nc bnc" id="L144" title="All 2 branches missed.">        if (downKeys.contains(left)){</span>
<span class="nc" id="L145">            dir.x = -1;</span>
<span class="nc" id="L146">            Pstate = state.WALK_LEFT;</span>
        }
<span class="nc bnc" id="L148" title="All 2 branches missed.">        if (downKeys.contains(right)){</span>
<span class="nc" id="L149">            dir.x = 1;</span>
<span class="nc" id="L150">            Pstate = state.WALK_RIGHT;</span>
        }
<span class="nc" id="L152">        return dir;</span>
    }

    /**
     * Alters the direction vector to account for collisions
     * @param dir .
     * @return .
     */
    public Vector2 colCorrect(Vector2 dir)
    {
<span class="nc" id="L162">        Vector2 colDir = new Vector2(dir.x,dir.y);</span>
<span class="nc bnc" id="L163" title="All 4 branches missed.">        if ((dir.x==1) &amp;&amp; collisionDetector.collidesRight()){colDir.x=0;}</span>
<span class="nc bnc" id="L164" title="All 4 branches missed.">        if ((dir.x==-1) &amp;&amp; collisionDetector.collidesLeft()){colDir.x=0;}</span>
<span class="nc bnc" id="L165" title="All 4 branches missed.">        if ((dir.y==1) &amp;&amp; collisionDetector.collidesUp()){colDir.y=0;}</span>
<span class="nc bnc" id="L166" title="All 4 branches missed.">        if ((dir.y==-1) &amp;&amp; collisionDetector.collidesDown()){colDir.y=0;}</span>
<span class="nc" id="L167">        return colDir;</span>
    }

    /**
     * Method to return animation to play
     * @param Pstate .
     * @return Anim
     */
    public Animation getAnim(state Pstate)
    {
<span class="nc" id="L177">        Vector2 dir = getDir();</span>
<span class="nc bnc" id="L178" title="All 2 branches missed.">        if (Objects.equals(dir, new Vector2(0, 0)))</span>
        {
<span class="nc bnc" id="L180" title="All 5 branches missed.">            switch (Pstate)</span>
            {
                case WALK_UP:
                case IDLE_UP:
<span class="nc" id="L184">                    return IDLE_UP;</span>
                case WALK_DOWN:
                case IDLE_DOWN:
<span class="nc" id="L187">                    return IDLE_DOWN;</span>
                case WALK_RIGHT:
                case IDLE_RIGHT:
<span class="nc" id="L190">                    return IDLE_RIGHT;</span>
                case WALK_LEFT:
                case IDLE_LEFT:
<span class="nc" id="L193">                    return IDLE_LEFT;</span>
            }
        }
        else
        {
<span class="nc bnc" id="L198" title="All 2 branches missed.">            if (dir.x == 1){</span>
<span class="nc" id="L199">                return WALK_RIGHT;</span>
<span class="nc bnc" id="L200" title="All 2 branches missed.">            } else if (dir.x == -1){</span>
<span class="nc" id="L201">                return WALK_LEFT;</span>
            }
<span class="nc bnc" id="L203" title="All 2 branches missed.">            if (dir.y == 1){</span>
<span class="nc" id="L204">                return WALK_UP;</span>
<span class="nc bnc" id="L205" title="All 2 branches missed.">            } else if (dir.y == -1){</span>
<span class="nc" id="L206">                return WALK_DOWN;</span>
            }

        }

<span class="nc" id="L211">        return null;</span>
    }
    @Override
    public void render(Camera projection, HesHustle game, ShapeRenderer shape){
<span class="nc" id="L215">        game.batch.begin();</span>
<span class="nc" id="L216">        game.batch.draw(txr,pos.x, pos.y, bounds.width, bounds.height);</span>
<span class="nc" id="L217">        game.batch.end();</span>



<span class="nc" id="L221">    }</span>

    /**
     * sets the nearest builiding value
     * @param BD .
     */
    public void setBD(Building BD){
<span class="nc" id="L228">        nearBD = BD;</span>
<span class="nc" id="L229">    }</span>
    public void interact(){
<span class="nc bnc" id="L231" title="All 4 branches missed.">        if (nearBD!=null &amp;&amp; !EM.isFrozen())</span>
        {
<span class="nc" id="L233">            EM.interact(nearBD.name);</span>
        }

<span class="nc" id="L236">    }</span>

    @Override
    public boolean keyDown(int keycode) {

<span class="nc" id="L241">        downKeys.add(keycode);</span>
<span class="nc bnc" id="L242" title="All 2 branches missed.">        if (keycode == Input.Keys.SPACE){</span>
<span class="nc" id="L243">            interact();</span>
        }
<span class="nc bnc" id="L245" title="All 2 branches missed.">        if (downKeys.size &gt;= 2){</span>

<span class="nc" id="L247">            return onMultipleKeysDown(keycode);</span>
        }
<span class="nc" id="L249">        return true;</span>

    }

    /**
     * When multiple keys pressed it cancels out opposing directions, added back on key up
     * @param keycode .
     * @return .
     */
    public boolean onMultipleKeysDown(int keycode){
<span class="nc bnc" id="L259" title="All 8 branches missed.">        if ((keycode==left &amp;&amp; downKeys.contains(right)) || (keycode==right &amp;&amp; downKeys.contains(left))) {</span>
<span class="nc" id="L260">            downKeys.remove(left);</span>
<span class="nc" id="L261">            downKeys.remove(right);</span>

<span class="nc" id="L263">            return true;</span>
        }
<span class="nc bnc" id="L265" title="All 8 branches missed.">        else if ((keycode==up &amp;&amp; downKeys.contains(down)) || (keycode==down &amp;&amp; downKeys.contains(up))) {</span>
<span class="nc" id="L266">            downKeys.remove(up);</span>
<span class="nc" id="L267">            downKeys.remove(down);</span>

<span class="nc" id="L269">            return true;</span>
        } else {
<span class="nc" id="L271">            downKeys.add(keycode);</span>

<span class="nc" id="L273">            return true;</span>
        }

    }

    @Override
    public boolean keyUp(int keycode) {
<span class="nc bnc" id="L280" title="All 2 branches missed.">        if (downKeys.contains(keycode))</span>
        {
<span class="nc" id="L282">            downKeys.remove(keycode);</span>
<span class="nc" id="L283">            return true;</span>
        }
        else
        {
<span class="nc bnc" id="L287" title="All 5 branches missed.">            switch(keycode)</span>
            {
                case up:
<span class="nc" id="L290">                    downKeys.add(down);</span>
<span class="nc" id="L291">                    break;</span>
                case down:
<span class="nc" id="L293">                    downKeys.add(up);</span>
<span class="nc" id="L294">                    break;</span>
                case left:
<span class="nc" id="L296">                    downKeys.add(right);</span>
<span class="nc" id="L297">                    break;</span>
                case right:
<span class="nc" id="L299">                    downKeys.add(left);</span>
                    break;
            }
        }
<span class="nc" id="L303">        return true;</span>
    }

    @Override
    public boolean keyTyped(char character) {
<span class="nc" id="L308">        return false;</span>
    }

    @Override
    public boolean touchDown(int screenX, int screenY, int pointer, int button) {
<span class="nc" id="L313">        return false;</span>
    }

    @Override
    public boolean touchUp(int screenX, int screenY, int pointer, int button) {
<span class="nc" id="L318">        return false;</span>
    }

    @Override
    public boolean touchCancelled(int screenX, int screenY, int pointer, int button) {
<span class="nc" id="L323">        return false;</span>
    }

    @Override
    public boolean touchDragged(int screenX, int screenY, int pointer) {
<span class="nc" id="L328">        return false;</span>
    }

    @Override
    public boolean mouseMoved(int screenX, int screenY) {
<span class="nc" id="L333">        return false;</span>
    }

    @Override
    public boolean scrolled(float amountX, float amountY) {
<span class="nc" id="L338">        return false;</span>
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.9.202303310957</span></div></body></html>